thing = thing[order(thing$padj),]
# unique(thing$padj)
write.csv(thing[,(!c(1:9) == 8)], file = gsea_filename, col.names = TRUE, row.names = FALSE)
set.seed(42)
lfc_shrink = lfc_shrink[!is.na(lfc_shrink$entrez),]
lfc_shrink = lfc_shrink[order(lfc_shrink$log2FoldChange, decreasing = TRUE),]
res_list = lfc_shrink$log2FoldChange
names(res_list) = lfc_shrink$entrez
# Fer da unique GSEA requests
GSEA_struct = read.gmt("m3.all.v2024.1.Mm.symbols.gmt")
gsea_filename = "M3_GSEA.csv"
# GSEA_struct = read.gmt("mh.all.v2024.1.Mm.symbols.gmt")
# gsea_filename = "MH_GSEA.csv"
# GSEA_struct = read.gmt("m2.all.v2024.1.Mm.symbols.gmt")
# gsea_filename = "M2_GSEA.csv"
# GSEA_struct = read.gmt("m5.all.v2024.1.Mm.symbols.gmt")
# gsea_filename = "M5_GSEA.csv"
# GSEA_struct = read.gmt("mh.all.v2024.1.Mm.entrez.gmt")
# gsea_filename = "MH_GSEA_entrez.csv"
# GSEA_struct = read.gmt("m2.all.v2024.1.Mm.entrez.gmt")
# gsea_filename = "M2_GSEA_entrez.csv"
# GSEA_struct = read.gmt("m3.all.v2024.1.Mm.entrez.gmt")
# gsea_filename = "M3_GSEA_entrez.csv"
# GSEA_struct = read.gmt("m5.all.v2024.1.Mm.entrez.gmt")
# gsea_filename = "M5_GSEA_entrez.csv"
# GSEA_struct$entrez = unname(unlist(AnnotationDbi::mapIds(org.Mm.eg.db, keys=GSEA_struct$gene, column="ENTREZID", keytype="SYMBOL", multiVals="first")))
build_list = list()
for(things in unique(GSEA_struct$term)){
build_list[[things]] = GSEA_struct$entrez[which(GSEA_struct$term == things)]
# build_list[[things]] = GSEA_struct$gene[which(GSEA_struct$term == things)]
}
# build_list
fgseaRes = fgsea(pathways = build_list, stats = res_list, minSize  = 1, maxSize  = 1000)
thing = fgseaRes %>% rowwise() %>%
mutate(leadingEdge = paste(leadingEdge, collapse=',')) %>%
ungroup()
thing$genes = unname(unlist(lapply( thing$leadingEdge, FUN = function(x){
if (x != ""){
# print(x)
entrez_ids = as.vector(unname(unlist(strsplit(x, ","))))
alias_names = unname(unlist(
AnnotationDbi::mapIds(
org.Mm.eg.db,
keys=entrez_ids,
column="SYMBOL",
keytype="ENTREZID",
multiVals="first")))
z = paste0(alias_names, collapse = ",")
} else {
z = NA
}
return(z)
})))
thing = thing[order(thing$padj),]
# unique(thing$padj)
write.csv(thing[,(!c(1:9) == 8)], file = gsea_filename, col.names = TRUE, row.names = FALSE)
thing
GSEA_struct
set.seed(42)
lfc_shrink = lfc_shrink[!is.na(lfc_shrink$entrez),]
lfc_shrink = lfc_shrink[order(lfc_shrink$log2FoldChange, decreasing = TRUE),]
res_list = lfc_shrink$log2FoldChange
names(res_list) = lfc_shrink$entrez
# Fer da unique GSEA requests
GSEA_struct = read.gmt("m3.all.v2024.1.Mm.symbols.gmt")
gsea_filename = "M3_GSEA.csv"
# GSEA_struct = read.gmt("mh.all.v2024.1.Mm.symbols.gmt")
# gsea_filename = "MH_GSEA.csv"
# GSEA_struct = read.gmt("m2.all.v2024.1.Mm.symbols.gmt")
# gsea_filename = "M2_GSEA.csv"
# GSEA_struct = read.gmt("m5.all.v2024.1.Mm.symbols.gmt")
# gsea_filename = "M5_GSEA.csv"
# GSEA_struct = read.gmt("mh.all.v2024.1.Mm.entrez.gmt")
# gsea_filename = "MH_GSEA_entrez.csv"
# GSEA_struct = read.gmt("m2.all.v2024.1.Mm.entrez.gmt")
# gsea_filename = "M2_GSEA_entrez.csv"
# GSEA_struct = read.gmt("m3.all.v2024.1.Mm.entrez.gmt")
# gsea_filename = "M3_GSEA_entrez.csv"
# GSEA_struct = read.gmt("m5.all.v2024.1.Mm.entrez.gmt")
# gsea_filename = "M5_GSEA_entrez.csv"
GSEA_struct$entrez = unname(unlist(AnnotationDbi::mapIds(org.Mm.eg.db, keys=GSEA_struct$gene, column="ENTREZID", keytype="SYMBOL", multiVals="first")))
build_list = list()
for(things in unique(GSEA_struct$term)){
build_list[[things]] = GSEA_struct$entrez[which(GSEA_struct$term == things)]
# build_list[[things]] = GSEA_struct$gene[which(GSEA_struct$term == things)]
}
# build_list
fgseaRes = fgsea(pathways = build_list, stats = res_list, minSize  = 1, maxSize  = 1000)
thing = fgseaRes %>% rowwise() %>%
mutate(leadingEdge = paste(leadingEdge, collapse=',')) %>%
ungroup()
thing$genes = unname(unlist(lapply( thing$leadingEdge, FUN = function(x){
if (x != ""){
# print(x)
entrez_ids = as.vector(unname(unlist(strsplit(x, ","))))
alias_names = unname(unlist(
AnnotationDbi::mapIds(
org.Mm.eg.db,
keys=entrez_ids,
column="SYMBOL",
keytype="ENTREZID",
multiVals="first")))
z = paste0(alias_names, collapse = ",")
} else {
z = NA
}
return(z)
})))
thing = thing[order(thing$padj),]
# unique(thing$padj)
write.csv(thing[,(!c(1:9) == 8)], file = gsea_filename, col.names = TRUE, row.names = FALSE)
set.seed(42)
lfc_shrink = lfc_shrink[!is.na(lfc_shrink$entrez),]
lfc_shrink = lfc_shrink[order(lfc_shrink$log2FoldChange, decreasing = TRUE),]
res_list = lfc_shrink$log2FoldChange
names(res_list) = lfc_shrink$entrez
# Fer da unique GSEA requests
# GSEA_struct = read.gmt("m3.all.v2024.1.Mm.symbols.gmt")
# gsea_filename = "M3_GSEA.csv"
GSEA_struct = read.gmt("mh.all.v2024.1.Mm.symbols.gmt")
gsea_filename = "MH_GSEA.csv"
# GSEA_struct = read.gmt("m2.all.v2024.1.Mm.symbols.gmt")
# gsea_filename = "M2_GSEA.csv"
# GSEA_struct = read.gmt("m5.all.v2024.1.Mm.symbols.gmt")
# gsea_filename = "M5_GSEA.csv"
# GSEA_struct = read.gmt("mh.all.v2024.1.Mm.entrez.gmt")
# gsea_filename = "MH_GSEA_entrez.csv"
# GSEA_struct = read.gmt("m2.all.v2024.1.Mm.entrez.gmt")
# gsea_filename = "M2_GSEA_entrez.csv"
# GSEA_struct = read.gmt("m3.all.v2024.1.Mm.entrez.gmt")
# gsea_filename = "M3_GSEA_entrez.csv"
# GSEA_struct = read.gmt("m5.all.v2024.1.Mm.entrez.gmt")
# gsea_filename = "M5_GSEA_entrez.csv"
GSEA_struct$entrez = unname(unlist(AnnotationDbi::mapIds(org.Mm.eg.db, keys=GSEA_struct$gene, column="ENTREZID", keytype="SYMBOL", multiVals="first")))
build_list = list()
for(things in unique(GSEA_struct$term)){
build_list[[things]] = GSEA_struct$entrez[which(GSEA_struct$term == things)]
# build_list[[things]] = GSEA_struct$gene[which(GSEA_struct$term == things)]
}
# build_list
fgseaRes = fgsea(pathways = build_list, stats = res_list, minSize  = 1, maxSize  = 1000)
thing = fgseaRes %>% rowwise() %>%
mutate(leadingEdge = paste(leadingEdge, collapse=',')) %>%
ungroup()
thing$genes = unname(unlist(lapply( thing$leadingEdge, FUN = function(x){
if (x != ""){
# print(x)
entrez_ids = as.vector(unname(unlist(strsplit(x, ","))))
alias_names = unname(unlist(
AnnotationDbi::mapIds(
org.Mm.eg.db,
keys=entrez_ids,
column="SYMBOL",
keytype="ENTREZID",
multiVals="first")))
z = paste0(alias_names, collapse = ",")
} else {
z = NA
}
return(z)
})))
thing = thing[order(thing$padj),]
# unique(thing$padj)
write.csv(thing[,(!c(1:9) == 8)], file = gsea_filename, col.names = TRUE, row.names = FALSE)
set.seed(42)
lfc_shrink = lfc_shrink[!is.na(lfc_shrink$entrez),]
lfc_shrink = lfc_shrink[order(lfc_shrink$log2FoldChange, decreasing = TRUE),]
res_list = lfc_shrink$log2FoldChange
names(res_list) = lfc_shrink$entrez
# Fer da unique GSEA requests
# GSEA_struct = read.gmt("m3.all.v2024.1.Mm.symbols.gmt")
# gsea_filename = "M3_GSEA.csv"
# GSEA_struct = read.gmt("mh.all.v2024.1.Mm.symbols.gmt")
# gsea_filename = "MH_GSEA.csv"
GSEA_struct = read.gmt("m2.all.v2024.1.Mm.symbols.gmt")
gsea_filename = "M2_GSEA.csv"
# GSEA_struct = read.gmt("m5.all.v2024.1.Mm.symbols.gmt")
# gsea_filename = "M5_GSEA.csv"
# GSEA_struct = read.gmt("mh.all.v2024.1.Mm.entrez.gmt")
# gsea_filename = "MH_GSEA_entrez.csv"
# GSEA_struct = read.gmt("m2.all.v2024.1.Mm.entrez.gmt")
# gsea_filename = "M2_GSEA_entrez.csv"
# GSEA_struct = read.gmt("m3.all.v2024.1.Mm.entrez.gmt")
# gsea_filename = "M3_GSEA_entrez.csv"
# GSEA_struct = read.gmt("m5.all.v2024.1.Mm.entrez.gmt")
# gsea_filename = "M5_GSEA_entrez.csv"
GSEA_struct$entrez = unname(unlist(AnnotationDbi::mapIds(org.Mm.eg.db, keys=GSEA_struct$gene, column="ENTREZID", keytype="SYMBOL", multiVals="first")))
build_list = list()
for(things in unique(GSEA_struct$term)){
build_list[[things]] = GSEA_struct$entrez[which(GSEA_struct$term == things)]
# build_list[[things]] = GSEA_struct$gene[which(GSEA_struct$term == things)]
}
# build_list
fgseaRes = fgsea(pathways = build_list, stats = res_list, minSize  = 1, maxSize  = 1000)
thing = fgseaRes %>% rowwise() %>%
mutate(leadingEdge = paste(leadingEdge, collapse=',')) %>%
ungroup()
thing$genes = unname(unlist(lapply( thing$leadingEdge, FUN = function(x){
if (x != ""){
# print(x)
entrez_ids = as.vector(unname(unlist(strsplit(x, ","))))
alias_names = unname(unlist(
AnnotationDbi::mapIds(
org.Mm.eg.db,
keys=entrez_ids,
column="SYMBOL",
keytype="ENTREZID",
multiVals="first")))
z = paste0(alias_names, collapse = ",")
} else {
z = NA
}
return(z)
})))
thing = thing[order(thing$padj),]
# unique(thing$padj)
write.csv(thing[,(!c(1:9) == 8)], file = gsea_filename, col.names = TRUE, row.names = FALSE)
set.seed(42)
lfc_shrink = lfc_shrink[!is.na(lfc_shrink$entrez),]
lfc_shrink = lfc_shrink[order(lfc_shrink$log2FoldChange, decreasing = TRUE),]
res_list = lfc_shrink$log2FoldChange
names(res_list) = lfc_shrink$entrez
# Fer da unique GSEA requests
# GSEA_struct = read.gmt("m3.all.v2024.1.Mm.symbols.gmt")
# gsea_filename = "M3_GSEA.csv"
# GSEA_struct = read.gmt("mh.all.v2024.1.Mm.symbols.gmt")
# gsea_filename = "MH_GSEA.csv"
# GSEA_struct = read.gmt("m2.all.v2024.1.Mm.symbols.gmt")
# gsea_filename = "M2_GSEA.csv"
GSEA_struct = read.gmt("m5.all.v2024.1.Mm.symbols.gmt")
gsea_filename = "M5_GSEA.csv"
# GSEA_struct = read.gmt("mh.all.v2024.1.Mm.entrez.gmt")
# gsea_filename = "MH_GSEA_entrez.csv"
# GSEA_struct = read.gmt("m2.all.v2024.1.Mm.entrez.gmt")
# gsea_filename = "M2_GSEA_entrez.csv"
# GSEA_struct = read.gmt("m3.all.v2024.1.Mm.entrez.gmt")
# gsea_filename = "M3_GSEA_entrez.csv"
# GSEA_struct = read.gmt("m5.all.v2024.1.Mm.entrez.gmt")
# gsea_filename = "M5_GSEA_entrez.csv"
GSEA_struct$entrez = unname(unlist(AnnotationDbi::mapIds(org.Mm.eg.db, keys=GSEA_struct$gene, column="ENTREZID", keytype="SYMBOL", multiVals="first")))
build_list = list()
for(things in unique(GSEA_struct$term)){
build_list[[things]] = GSEA_struct$entrez[which(GSEA_struct$term == things)]
# build_list[[things]] = GSEA_struct$gene[which(GSEA_struct$term == things)]
}
# build_list
fgseaRes = fgsea(pathways = build_list, stats = res_list, minSize  = 1, maxSize  = 1000)
thing = fgseaRes %>% rowwise() %>%
mutate(leadingEdge = paste(leadingEdge, collapse=',')) %>%
ungroup()
thing$genes = unname(unlist(lapply( thing$leadingEdge, FUN = function(x){
if (x != ""){
# print(x)
entrez_ids = as.vector(unname(unlist(strsplit(x, ","))))
alias_names = unname(unlist(
AnnotationDbi::mapIds(
org.Mm.eg.db,
keys=entrez_ids,
column="SYMBOL",
keytype="ENTREZID",
multiVals="first")))
z = paste0(alias_names, collapse = ",")
} else {
z = NA
}
return(z)
})))
thing = thing[order(thing$padj),]
# unique(thing$padj)
write.csv(thing[,(!c(1:9) == 8)], file = gsea_filename, col.names = TRUE, row.names = FALSE)
res
# this chunk is just to keep the _files directory even when we turn off cacheing
# save start time for script
start_tm <- Sys.time()
start_tm
outdir <- file.path("deseq2_out_files", params$comparison_name)
dir.create(outdir, recursive=TRUE)
knitr::opts_chunk$set(echo=TRUE, warning=TRUE, message=TRUE, cache=FALSE, cache.lazy = FALSE, dev=c('png','pdf'),
fig.width=4, fig.height=4, fig.path=paste0(outdir, "/individual_figures/"))
library(dplyr)
library(stringr)
library(ggplot2)
library(readr)
library(ggrepel)
library(ComplexHeatmap)
library(DESeq2)
# For GO and GSEA:
library(clusterProfiler)
library(org.Mm.eg.db)
library(fgsea)
getwd()
# se <- readRDS(paste0("../../", params$se_obj))
se = readRDS("/varidata/research/projects/bbc/research/JONR_20250224_RNA_VBCS-1355/run3_combined/rnaseq_workflow/results/SummarizedExperiment/sce.rds")
# subset se to just samples in this comparison (relevant esp if variance is diff between groups)
# se <- se[, colData(se)$group %in% c(params$group_test, params$group_reference)]
colData(se)
# factor the group column to make sure the reference group is the first level
# se$group <- factor(se$group, levels=c(params$group_reference, params$group_test))
# se$group <- factor(se$group, levels=c("ctrl", "ko"))
assayNames(se)
stopifnot(assayNames(se)[1] == "counts")
se
dds <- DESeqDataSet(se, design = ~ group)
png( "grouped_PCA_all_samples.png")
plotPCA( vst(dds), intgroup = "group" )
dev.off()
pcaplot = plotPCA( vst(dds), intgroup = "group" )
pcaplot
# prefilter genes, keeping only genes with 10 or more total read counts across samples
keep <- rowSums(counts(dds)) >= 10
message(str_glue("Keeping {sum(keep)} genes."))
dds <- dds[keep, ]
dds <- DESeq(dds)
message(paste0("Coefficient names are: ", paste(resultsNames(dds), collapse = " ")))
contrast <- c("group", "ko", "ctrl")
# fdr_cutoff <- params$fdr_cutoff
fdr_cutoff = 0.05
res <- results(dds, contrast=contrast, alpha=fdr_cutoff)
res <- res[order(res$pvalue), ]
df <- as.data.frame(res)
data.frame(
UP=sum(df$padj <= fdr_cutoff & df$log2FoldChange > 0, na.rm = TRUE),
DWN=sum(df$padj <= fdr_cutoff & df$log2FoldChange < 0, na.rm = TRUE),
Tested=sum(!is.na(df$padj))
)
lfc_shrink <- lfcShrink(dds, contrast=contrast, type="ashr")
lfc_shrink <- lfc_shrink[order(lfc_shrink$pvalue), ]
set.seed(42)
GSEA_funk = function(res, database, pval_cutoff = 0.1, minGSSize = 1, maxGSSize = 1000 ){
alt_rownames = gsub("\\.[0-9]*$", "", rownames(res))
alt_res = res
rownames(alt_res) = alt_rownames
# We've already built the entrez column, so this step isn't required
# res$entrez = unname(unlist(AnnotationDbi::mapIds(database, keys=rownames(alt_res), column="ENTREZID", keytype="ENSEMBL", multiVals="first")))
res = res[!is.na(res$entrez),]
res = res[order(res$log2FoldChange, decreasing = TRUE),]
res_list = res$log2FoldChange
names(res_list) = res$entrez
# print(res_list)
res_GSEA = as.data.frame(gseGO(geneList = res_list,
OrgDb = database,
minGSSize = minGSSize,
maxGSSize = maxGSSize,
pvalueCutoff = pval_cutoff))
res_GSEA$genes = unname(unlist(lapply( res_GSEA$core_enrichment, FUN = function(x){
if (x != ""){
# print(x)
entrez_ids = as.vector(unname(unlist(strsplit(x, "/"))))
alias_names = unname(unlist(
AnnotationDbi::mapIds(
database,
keys=entrez_ids,
column="SYMBOL",
keytype="ENTREZID",
multiVals="first")))
z = paste0(alias_names, collapse = "/")
} else {
z = NA
}
return(z)
})))
# print(res_GSEA)
return(res_GSEA)
}
lfc_shrink$entrez = unname(unlist(AnnotationDbi::mapIds(org.Mm.eg.db, keys=rownames(lfc_shrink), column="ENTREZID", keytype="SYMBOL", multiVals="first")))
gsea_Results = GSEA_funk(lfc_shrink, org.Mm.eg.db)
lfc_shrink = lfc_shrink[!is.na(lfc_shrink$entrez),]
lfc_shrink = lfc_shrink[order(lfc_shrink$log2FoldChange, decreasing = TRUE),]
res_list = lfc_shrink$log2FoldChange
names(res_list) = lfc_shrink$entrez
# Fer da unique GSEA requests
# GSEA_struct = read.gmt("m3.all.v2024.1.Mm.symbols.gmt")
# gsea_filename = "M3_GSEA.csv"
# GSEA_struct = read.gmt("mh.all.v2024.1.Mm.symbols.gmt")
# gsea_filename = "MH_GSEA.csv"
# GSEA_struct = read.gmt("m2.all.v2024.1.Mm.symbols.gmt")
# gsea_filename = "M2_GSEA.csv"
# GSEA_struct = read.gmt("m5.all.v2024.1.Mm.symbols.gmt")
# gsea_filename = "M5_GSEA.csv"
GSEA_struct$entrez = unname(unlist(AnnotationDbi::mapIds(org.Mm.eg.db, keys=GSEA_struct$gene, column="ENTREZID", keytype="SYMBOL", multiVals="first")))
res
# this chunk is just to keep the _files directory even when we turn off cacheing
# save start time for script
start_tm <- Sys.time()
start_tm
outdir <- file.path("deseq2_out_files", params$comparison_name)
dir.create(outdir, recursive=TRUE)
knitr::opts_chunk$set(echo=TRUE, warning=TRUE, message=TRUE, cache=FALSE, cache.lazy = FALSE, dev=c('png','pdf'),
fig.width=4, fig.height=4, fig.path=paste0(outdir, "/individual_figures/"))
library(dplyr)
library(stringr)
library(ggplot2)
library(readr)
library(ggrepel)
library(ComplexHeatmap)
library(DESeq2)
# For GO and GSEA:
library(clusterProfiler)
library(org.Mm.eg.db)
library(fgsea)
getwd()
# se <- readRDS(paste0("../../", params$se_obj))
se = readRDS("/varidata/research/projects/bbc/research/JONR_20250224_RNA_VBCS-1355/run3_combined/rnaseq_workflow/results/SummarizedExperiment/sce.rds")
# subset se to just samples in this comparison (relevant esp if variance is diff between groups)
# se <- se[, colData(se)$group %in% c(params$group_test, params$group_reference)]
colData(se)
# factor the group column to make sure the reference group is the first level
# se$group <- factor(se$group, levels=c(params$group_reference, params$group_test))
# se$group <- factor(se$group, levels=c("ctrl", "ko"))
assayNames(se)
stopifnot(assayNames(se)[1] == "counts")
se
dds <- DESeqDataSet(se, design = ~ group)
png( "grouped_PCA_all_samples.png")
plotPCA( vst(dds), intgroup = "group" )
dev.off()
pcaplot = plotPCA( vst(dds), intgroup = "group" )
pcaplot
# prefilter genes, keeping only genes with 10 or more total read counts across samples
keep <- rowSums(counts(dds)) >= 10
message(str_glue("Keeping {sum(keep)} genes."))
dds <- dds[keep, ]
dds <- DESeq(dds)
message(paste0("Coefficient names are: ", paste(resultsNames(dds), collapse = " ")))
contrast <- c("group", "ko", "ctrl")
# fdr_cutoff <- params$fdr_cutoff
fdr_cutoff = 0.05
res <- results(dds, contrast=contrast, alpha=fdr_cutoff)
res <- res[order(res$pvalue), ]
# out_counts = vst(dds, ) # I was trying to combine the results df and normalized log2-transformed counts together
res
df
df <- as.data.frame(res)
data.frame(
UP=sum(df$padj <= fdr_cutoff & df$log2FoldChange > 0, na.rm = TRUE),
DWN=sum(df$padj <= fdr_cutoff & df$log2FoldChange < 0, na.rm = TRUE),
Tested=sum(!is.na(df$padj))
)
lfc_shrink <- lfcShrink(dds, contrast=contrast, type="ashr")
lfc_shrink <- lfc_shrink[order(lfc_shrink$pvalue), ]
lfc_shrink <- lfcShrink(dds, contrast=contrast, type="ashr")
lfc_shrink <- lfc_shrink[order(lfc_shrink$pvalue), ]
write_tsv(df, file.path(outdir, "de_res.tsv"))
write_rds(df, file.path(outdir, "de_res.rds"))
vsd
vsd <- vst(dds, blind=FALSE)
vsd
assay(vsd)
rownames(df)
assay(vsd)[match(rownames(df),rownames(assay(vsd))),]
df
assay(vsd)[match(rownames(df),rownames(assay(vsd))),]
all(rownames(assay(vsd)[match(rownames(df),rownames(assay(vsd))),]) == rownames(df))
combined_df = cbind(df, assay(vsd)[match(rownames(df),rownames(assay(vsd))),])
write.csv(combined_df, file = "results_and_counts.csv")
pos_gene_ontology = enrichGO(gene   = rownames(res[res$padj < 0.05,])[(!is.na(rownames(res[res$padj < 0.05,])) & (rownames(res[res$log2FoldChange > 0,]))], # Only significant genes
pos_gene_ontology = enrichGO(gene   = rownames(res[res$padj < 0.05,])[(!is.na(rownames(res[res$padj < 0.05,])) & (rownames(res[res$log2FoldChange > 0,])))], # Only significant genes
OrgDb         = org.Mm.eg.db,
keyType       = 'SYMBOL',
ont           = "ALL",
pAdjustMethod = "BH",
pvalueCutoff  = 0.01,
qvalueCutoff  = 0.05,
readable      = TRUE)
res = res[!is.na(res$padj),]
gene_ontology = enrichGO(gene   = rownames(res[res$padj < 0.05,])[!is.na(rownames(res[res$padj < 0.05,]))], # Only significant genes
OrgDb         = org.Mm.eg.db,
keyType       = 'SYMBOL',
ont           = "ALL",
pAdjustMethod = "BH",
pvalueCutoff  = 0.01,
qvalueCutoff  = 0.05,
readable      = TRUE)
rownames(res[res$padj < 0.05,])[(!is.na(rownames(res[res$padj < 0.05,])) & (rownames(res[res$log2FoldChange > 0,])))]
(!is.na(rownames(res[res$padj < 0.05,])) & (rownames(res[res$log2FoldChange > 0,])))
(!is.na(rownames(res[res$padj < 0.05,]))
!is.na(rownames(res[res$padj < 0.05,]))
rownames(res[res$padj < 0.05 & res$log2FoldChange > 0,])[!is.na(rownames(res[res$padj < 0.05,]))]
rownames(res[res$padj < 0.05 & res$log2FoldChange > 0,])[!is.na(rownames(res[res$padj < 0.05,]))]
pos_gene_ontology = enrichGO(gene   = rownames(res[res$padj < 0.05 & res$log2FoldChange > 0,])[!is.na(rownames(res[res$padj < 0.05,]))], # Only significant genes
OrgDb         = org.Mm.eg.db,
keyType       = 'SYMBOL',
ont           = "ALL",
pAdjustMethod = "BH",
pvalueCutoff  = 0.01,
qvalueCutoff  = 0.05,
readable      = TRUE)
pos_gene_ontology
write.csv(as.data.frame(pos_gene_ontology), file = "pos_logFC_sigGene_overRep.csv")
rownames(res[res$padj < 0.05 & res$log2FoldChange > 0,])[!is.na(rownames(res[res$padj < 0.05 & res$log2FoldChange > 0,]))]
rownames(res[res$padj < 0.05,])[!is.na(rownames(res[res$padj < 0.05,]))]
neg_gene_ontology = enrichGO(gene   = rownames(res[res$padj < 0.05 & res$log2FoldChange < 0,])[!is.na(rownames(res[res$padj < 0.05 & res$log2FoldChange < 0,]))], # Only significant genes
OrgDb         = org.Mm.eg.db,
keyType       = 'SYMBOL',
ont           = "ALL",
pAdjustMethod = "BH",
pvalueCutoff  = 0.01,
qvalueCutoff  = 0.05,
readable      = TRUE)
write.csv(as.data.frame(neg_gene_ontology), file = "neg_logFC_sigGene_overRep.csv")
library(dplyr)
library(stringr)
library(ggplot2)
library(readr)
library(ggrepel)
library(ComplexHeatmap)
library(DESeq2)
# For GO and GSEA:
library(clusterProfiler)
library(org.Mm.eg.db)
library(fgsea)
sessionInfo()
