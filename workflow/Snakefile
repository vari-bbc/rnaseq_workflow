import pandas as pd
import numpy as np
import os
from shutil import which
from snakemake.utils import validate, min_version
import itertools

##### set minimum snakemake version #####
min_version("7.25.0")

##### load config and sample sheets #####

configfile: "config/config.yaml"

units = pd.read_table(config["units"], dtype={"sample" : str, "group" : str, "fq1" : str, "fq2" : str, "RG" : str})
units["RG"] = units["RG"].fillna("")
validate(units, "../schema/units.schema.yaml")
units['group_index'] = units.groupby('sample').cumcount().astype(str)
print(units)
if not (units['fq1'].is_unique and units['fq2'].is_unique):
    raise Exception('Same fastq specified in more than one row.')

samples = units[["sample","group"]].drop_duplicates()
if not samples['sample'].is_unique:
    raise Exception('A sample has more than one group.')
valid_groups = samples.groupby(['group'])['group'].count() > 1

if not (valid_groups.all()):
    raise Exception('Each group in the samplesheet must have at least two samples.')

if (config['call_variants']):
    # read grouped contigs
    contigs_file = config["grouped_contigs"]
    contig_groups = pd.read_table(contigs_file)
    contig_groups['contigs'].replace('', np.nan, inplace=True) # unplaced_contigs can be empty for certain references.
    contig_groups.dropna(subset=['contigs'], inplace=True)

    # check chromosomes/contigs parsed correctly by comparing to fai.
    fai_file = config["ref"]["fai"]
    contigs_fai = sorted(pd.read_table(fai_file, names=['name','len','offset','linebases','linewidth'])['name'].values)

    contigs_parsed = [x.split(',') for x in contig_groups['contigs'].values]
    contigs_parsed_flat = sorted(list(itertools.chain.from_iterable(contigs_parsed)))

    assert contigs_fai == contigs_parsed_flat, "Chromosomes in grouped contigs file do not match fai."

    include: 'rules/variants.smk'

# Need this directive because both PE and SE versions of these rules produce the trimmed R1 output files.
ruleorder: trim_galore_PE > trim_galore_SE

# below is to process quick ref genome information: 
ref_base_dir="/varidata/research/projects/bbc/versioned_references/"

if config['quick_ref']['species_name'] and not config['quick_ref']['ref_genome_version']:
    config['ref']['index']=ref_base_dir+"latest/data/"+config['quick_ref']['species_name']+"/indexes/star"
    config['ref']['salmon_index']=ref_base_dir+"latest/data/"+config['quick_ref']['species_name']+"/indexes/salmon/"+config['quick_ref']['species_name']
    config['ref']['annotation']=ref_base_dir+"latest/data/"+config['quick_ref']['species_name']+"/annotation/"+config['quick_ref']['species_name']+".gtf"
if config['quick_ref']['species_name'] and config['quick_ref']['ref_genome_version']: 
    config['ref']['index']=ref_base_dir+config['quick_ref']['ref_genome_version']+"/data/"+config['quick_ref']['species_name']+"/indexes/star"
    config['ref']['salmon_index']=ref_base_dir+config['quick_ref']['ref_genome_version']+"/data/"+config['quick_ref']['species_name']+"/indexes/salmon/"+config['quick_ref']['species_name']
    config['ref']['annotation']=ref_base_dir+config['quick_ref']['ref_genome_version']+"/data/"+config['quick_ref']['species_name']+"/annotation/"+config['quick_ref']['species_name']+".gtf"

rule all:
    input:
        "results/multiqc/multiqc_report.html",
        expand("results/SummarizedExperiment/{pref}.rds", pref=['SummarizedExperiment', 'sce']),
        expand("results/avg_bigwigs/{group}.unstr.bw", group=pd.unique(samples['group'])),
        "results/variant_calling/final/07a_variant_annot/all.merged.filt.PASS.snpeff.vcf.gz" if (config["call_variants"]) else [],
        "results/variant_calling/final/07b_snp_pca_and_dendro/snprelate.html" if (config["call_variants"]) else [],

include:
    'rules/RNAseq.smk'
include:
    'rules/qc.smk'
include:
    'rules/visualisation.smk'
